unit PasParser;

{
  Parser for Pascal source files.

  Written by Keith Wood, 31 July 1998.
}

{$R-}

interface

uses
  SysUtils, Windows, Classes;

const
  { TParser special tokens }
  toEOF        = Char(0);
  toIdentifier = Char(1);
  toReserved   = Char(2);
  toString     = Char(3);
  toComment    = Char(4);
  toNumber     = Char(5);

type
  { TPascalParser }
  TPascalParser = class(TObject)
  private
    FStream: TStream;
    FOrigin: Longint;
    FBuffer: PChar;
    FBufPtr: PChar;
    FBufEnd: PChar;
    FSourcePtr: PChar;
    FSourceEnd: PChar;
    FTokenPtr: PChar;
    FStringPtr: PChar;
    FSourceLine: Integer;
    FSaveChar: Char;
    FToken: Char;
    FWantAsSource: Boolean;
    procedure ReadBuffer;
    procedure SkipBlanks;
  public
    constructor Create(stmStream: TStream; bWantAsSource: Boolean);
    destructor Destroy; override;
    procedure CheckToken(cToken: Char);
    procedure CheckTokenSymbol(const sSymbol: string);
    procedure ErrorStr(const sMessage: string);
    function NextToken: Char;
    function SourcePos: Longint;
    function TokenFloat: Extended;
    function TokenInt: Longint;
    function TokenString: string;
    function TokenSymbolIs(const sSymbol: string): Boolean;
    property SourceLine: Integer read FSourceLine;
    property Token: Char read FToken;
    property WantAsSource: Boolean read FWantAsSource write FWantAsSource;
  end;

implementation

uses
  Consts, TypInfo;

{ TPascalParser }

const
  ParseBufSize = 4096;
  sIdentifierExpected = 'Identifier expected';
  sReservedExpected   = 'Reserved word expected';
  sStringExpected     = 'String expected';
  sCommentExpected    = 'Comment expected';
  sNumberExpected     = 'Number expected';
  sCharacterExpected  = 'Character (%s) expected';
  sWordExpected       = 'Identifier (%s) expected';
  sParserError        = 'Error in parser on sourceline %d: %s';
  sInvalidString      = 'Invalid string';
  sInvalidComment     = 'Invalid comment';
  sLineTooLong        = 'Input line is too long';

var
  slsReserved: TStringList;

constructor TPascalParser.Create(stmStream: TStream; bWantAsSource: Boolean);
begin
  FStream := stmStream;
  FWantAsSource := bWantAsSource;
  GetMem(FBuffer, ParseBufSize);
  FBuffer[0] := #0;
  FBufPtr := FBuffer;
  FBufEnd := FBuffer + ParseBufSize;
  FSourcePtr := FBuffer;
  FSourceEnd := FBuffer;
  FTokenPtr := FBuffer;
  FSourceLine := 1;
  NextToken;
end;

destructor TPascalParser.Destroy;
begin
  if FBuffer <> nil then
  begin
    FStream.Seek(Longint(FTokenPtr) - Longint(FBufPtr), 1);
    FreeMem(FBuffer, ParseBufSize);
  end;
end;

procedure TPascalParser.CheckToken(cToken: Char);
begin
  if Token <> cToken then
    case cToken of
      toIdentifier: ErrorStr(sIdentifierExpected);
      toReserved:   ErrorStr(sReservedExpected);
      toString:     ErrorStr(sStringExpected);
      toComment:    ErrorStr(sCommentExpected);
      toNumber:     ErrorStr(sNumberExpected);
      else          ErrorStr(Format(sCharacterExpected, [cToken]));
    end;
end;

procedure TPascalParser.CheckTokenSymbol(const sSymbol: string);
begin
  if not TokenSymbolIs(sSymbol) then
    ErrorStr(Format(sWordExpected, [sSymbol]));
end;

procedure TPascalParser.ErrorStr(const sMessage: string);
begin
  raise EParserError.Create(Format(sParserError, [FSourceLine, sMessage]));
end;

function TPascalParser.NextToken: Char;
var
  i: Integer;
  p, s: PChar;
begin
  SkipBlanks;
  p := FSourcePtr;
  FTokenPtr := p;
  case p^ of
    'A'..'Z', 'a'..'z', '_':  { Identifier or reserved word }
      begin
        Inc(p);
        while p^ in ['A'..'Z', 'a'..'z', '0'..'9', '_'] do
          Inc(p);
        Result := toIdentifier;
      end;
    '#', '''':                { String literal }
      begin
        s := p;
        while True do
          case p^ of
            '#':
              begin
                Inc(p);
                if WantAsSource then
                  Inc(s);
                i := 0;
                while p^ in ['0'..'9'] do
                begin
                  i := i * 10 + (Ord(p^) - Ord('0'));
                  Inc(p);
                  if WantAsSource then
                    Inc(s);
                end;
                if not WantAsSource then
                begin
                  s^ := Chr(i);
                  Inc(s);
                end;
              end;
            '''':
              begin
                Inc(p);
                if WantAsSource then
                  Inc(s);
                while True do
                begin
                  case p^ of
                    #0, #10, #13:
                      ErrorStr(sInvalidString);
                    '''':
                      begin
                        Inc(p);
                        if WantAsSource then
                          Inc(s);
                        if p^ <> '''' then
                          Break;
                      end;
                  end;
                  if not WantAsSource then
                    s^ := p^;
                  Inc(p);
                  Inc(s);
                end;
              end;
          else
            Break;
          end;
        FStringPtr := s;
        Result := toString;
      end;
    '{':                      { Comment }
      begin
        s := p;
        Inc(p);
        if WantAsSource then
          Inc(s);
        while True do
        begin
          case p^ of
            #0:
              ErrorStr(sInvalidComment);
            #10:
              Inc(FSourceLine);
            '}':
              begin
                Inc(p);
                if WantAsSource then
                  Inc(s);
                Break;
              end;
          end;
          s^ := p^;
          Inc(p);
          Inc(s);
        end;
        FStringPtr := s;
        Result := toComment;
      end;
    '/':                      { Comment - possibly }
      begin
        Result := p^;
        s := p;
        Inc(p);
        if WantAsSource then
          Inc(s);
        if p^ = '/' then      { Comment definitely }
        begin
          Inc(p);
          if WantAsSource then
            Inc(s);
          while True do
          begin
            case p^ of
              #0:
                ErrorStr(sInvalidComment);
              #13, #10:
                Break;
            end;
            s^ := p^;
            Inc(p);
            Inc(s);
          end;
          FStringPtr := s;
          Result := toComment;
        end;
      end;
    '(':                      { Comment - possibly }
      begin
        Result := p^;
        s := p;
        Inc(p);
        if WantAsSource then
          Inc(s);
        if p^ = '*' then      { Comment definitely }
        begin
          Inc(p);
          if WantAsSource then
            Inc(s);
          while True do
          begin
            case p^ of
              #0:
                ErrorStr(sInvalidComment);
              #10:
                Inc(FSourceLine);
              '*':
                begin
                  s^ := p^;
                  Inc(p);
                  if p^ = ')' then
                  begin
                    if WantAsSource then
                      Inc(s);
                    s^ := p^;
                    Inc(p);
                    if WantAsSource then
                      Inc(s);
                    Break;
                  end
                  else
                    Inc(s);
                end;
            end;
            s^ := p^;
            Inc(p);
            Inc(s);
          end;
          FStringPtr := s;
          Result := toComment;
        end;
      end;
    '$':                      { Hexadecimal literal }
      begin
        Inc(p);
        while p^ in ['0'..'9', 'A'..'F', 'a'..'f'] do
          Inc(p);
        Result := toNumber;
      end;
    '-', '0'..'9':            { Numeric literal }
      begin
        Inc(p);
        while p^ in ['0'..'9', '.', 'e', 'E', '+', '-'] do
          Inc(p);
        Result := toNumber;
      end;
    else                      { Single character }
      Result := p^;
      if Result <> toEOF then
        Inc(p);
  end;
  FSourcePtr := p;
  if (Result = toIdentifier) and (slsReserved.IndexOf(TokenString) > -1) then
    Result := toReserved;
  FToken := Result;
end;

procedure TPascalParser.ReadBuffer;
var
  Count: Integer;
begin
  Inc(FOrigin, FSourcePtr - FBuffer);
  FSourceEnd[0] := FSaveChar;
  Count := FBufPtr - FSourcePtr;
  if Count <> 0 then Move(FSourcePtr[0], FBuffer[0], Count);
  FBufPtr := FBuffer + Count;
  Inc(FBufPtr, FStream.Read(FBufPtr[0], FBufEnd - FBufPtr));
  FSourcePtr := FBuffer;
  FSourceEnd := FBufPtr;
  if FSourceEnd = FBufEnd then
  begin
    FSourceEnd := LineStart(FBuffer, FSourceEnd - 1);
    if FSourceEnd = FBuffer then
      ErrorStr(sLineTooLong);
  end;
  FSaveChar := FSourceEnd[0];
  FSourceEnd[0] := #0;
end;

procedure TPascalParser.SkipBlanks;
begin
  while True do
  begin
    case FSourcePtr^ of
      #0:
        begin
          ReadBuffer;
          if FSourcePtr^ = #0 then
            Exit;
          Continue;
        end;
      #10:
        Inc(FSourceLine);
      #33..#255:
        Exit;
      else
        if WantAsSource then
          Exit;
    end;
    Inc(FSourcePtr);
  end;
end;

function TPascalParser.SourcePos: Longint;
begin
  Result := FOrigin + (FTokenPtr - FBuffer);
end;

function TPascalParser.TokenFloat: Extended;
begin
  Result := StrToFloat(TokenString);
end;

function TPascalParser.TokenInt: Longint;
begin
  Result := StrToInt(TokenString);
end;

function TPascalParser.TokenString: string;
var
  i: Integer;
begin
  if FToken in [toString, toComment] then
    i := FStringPtr - FTokenPtr
  else
    i := FSourcePtr - FTokenPtr;
  SetString(Result, FTokenPtr, i);
end;

function TPascalParser.TokenSymbolIs(const sSymbol: string): Boolean;
begin
  Result := (Token in [toIdentifier, toReserved]) and
    (CompareText(sSymbol, TokenString) = 0);
end;

initialization
  slsReserved := TStringList.Create;
  with slsReserved do
  begin
    { Reserved words }
    Add('and');
    Add('array');
    Add('as');
    Add('asm');
    Add('begin');
    Add('case');
    Add('class');
    Add('constructor');
    Add('destructor');
    Add('dispinterface');
    Add('div');
    Add('do');
    Add('downto');
    Add('else');
    Add('end');
    Add('except');
    Add('exports');
    Add('file');
    Add('finalization');
    Add('finally');
    Add('for');
    Add('function');
    Add('goto');
    Add('if');
    Add('implementation');
    Add('in');
    Add('inherited');
    Add('initialization');
    Add('inline');
    Add('interface');
    Add('is');
    Add('label');
    Add('library');
    Add('mod');
    Add('nil');
    Add('not');
    Add('object');
    Add('of');
    Add('or');
    Add('out');
    Add('packed');
    Add('procedure');
    Add('program');
    Add('property');
    Add('raise');
    Add('record');
    Add('repeat');
    Add('resourcestring');
    Add('set');
    Add('shl');
    Add('shr');
    Add('string');
    Add('stringresource');
    Add('then');
    Add('threadvar');
    Add('to');
    Add('try');
    Add('type');
    Add('unit');
    Add('until');
    Add('uses');
    Add('var');
    Add('while');
    Add('with');
    Add('xor');
    { Standard directives }
    Add('absolute');
    Add('abstract');
    Add('assembler');
    Add('automated');
    Add('cdecl');
    Add('default');
    Add('dispid');
    Add('dynamic');
    Add('export');
    Add('external');
    Add('far');
    Add('forward');
    Add('index');
    Add('message');
    Add('name');
    Add('near');
    Add('nodefault');
    Add('override');
    Add('pascal');
    Add('private');
    Add('protected');
    Add('public');
    Add('published');
    Add('read');
    Add('readonly');
    Add('register');
    Add('resident');
    Add('safecall');
    Add('stdcall');
    Add('stored');
    Add('virtual');
    Add('write');
    Add('writeonly');
    Sorted := True;
  end;
finalization
  slsReserved.Free;
end.
